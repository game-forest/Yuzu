using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SourceGenerator
{
	[Generator]
	public class GenerateStaticYuzuSerializeIfMethod : IIncrementalGenerator
	{
		private const string SerializeIfAttributeString = "Yuzu.YuzuSerializeIf";

		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
				SerializeIfAttributeString,
				(syntaxNode, cancellationToken) => {
					return syntaxNode is MemberDeclarationSyntax
						|| (syntaxNode is VariableDeclaratorSyntax
							&& syntaxNode.Parent is VariableDeclarationSyntax
							&& syntaxNode.Parent.Parent is FieldDeclarationSyntax
						);
				},
				(context, cancellationToken) => {
					string methodName = null;
					var attributes = context.TargetSymbol.GetAttributes();
					foreach (var attribute in attributes) {
						if (attribute.AttributeClass.ToDisplayString() == SerializeIfAttributeString) {
							methodName = attribute.ConstructorArguments[0].Value as string;
							break;
						}
					}
					var ct = context.TargetSymbol.ContainingType;
					ISymbol? methodSymbol = null;
					do {
						var methods = ct.GetMembers().Where(m => m.Name == methodName);
						if (methods.Any()) {
							methodSymbol = methods.First();
						}
						ct = ct.BaseType;
					} while (ct != null);
					return methodSymbol;
				}
			);
			provider = provider
				.Where(s => s != null && !s.IsStatic)
				.Collect()
				.SelectMany((s, _) => s.Distinct(SymbolEqualityComparer.Default));
			context.RegisterSourceOutput(
				provider,
				(context, symbol) => {
					var containingTypes = new List<INamedTypeSymbol>();
					var ct = symbol.ContainingType;
					while (ct != null) {
						containingTypes.Add(ct);
						ct = ct.ContainingType;
					}
					var cns = containingTypes.Last().ContainingNamespace;
					int indentLevel = 0;
					var sb = new StringBuilder();
					P("// <auto-generated/>");
					P("using System;");
					P($"namespace {cns.ToDisplayString()};");
					P("");
					string className = "";
					for (int i = containingTypes.Count - 1; i >= 0; i--) {
						ct = containingTypes[i];
						var accessibiliy = ct.DeclaredAccessibility;
						className = ct.ToDisplayString(new SymbolDisplayFormat(
							genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters
							| SymbolDisplayGenericsOptions.IncludeVariance
							| SymbolDisplayGenericsOptions.IncludeTypeConstraints
						));
						var typeKind = ct.TypeKind.ToString().ToLower();
						if (typeKind == "structure") typeKind = "struct";
						var recordString = ct.IsRecord ? "record " : "";
						var staticString = ct.IsStatic ? "static " : "";
						var readonlyString = ct.IsReadOnly ? "readonly " : "";
						P(
							$"{accessibiliy.ToString().ToLower()} " +
							$"{staticString}{readonlyString}partial {recordString}{typeKind} {className}"
						);
						P("{");
						indentLevel++;
					}
					P($"public static bool Yuzu_{symbol.Name}_Static(object instance, object _)");
					P("{");
					indentLevel++;
					P($"return (({className})instance).{symbol.Name}();");
					indentLevel--;
					P("}");
					for (int i = containingTypes.Count - 1; i >= 0; i--) {
						indentLevel--;
						P("}");
					}
					var prefix = string.Join("_", containingTypes.Select(s => s.Name).Reverse());
					context.AddSource($"{prefix}_{symbol.Name}.g.cs", sb.ToString());
					void P(string s)
					{
						if (indentLevel > 0 || !string.IsNullOrEmpty(s)) {
							sb.Append('\t', indentLevel);
							sb.Append(s);
						}
						sb.Append("\n");
					}
				}
			);
		}
	}
}
